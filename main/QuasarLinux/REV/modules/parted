#!/bin/bash
set -euo pipefail
UEFI_MODE=0
export LUKS_MODE=0
[ -d /sys/firmware/efi ] && UEFI_MODE=1
clear
echo "$SELECT_DISK"
lsblk -d -o NAME,SIZE,MODEL,TYPE

read -p "$ENTER_DISK_NAME" DISK
export DISK="/dev/$DISK"
if [ ! -e "$DISK" ]; then
    printf "${DISK_ERROR}\n" "$DISK"
    exit 1
fi

#   BEST_COMPRESS_SPEED
BLANCE="balance"
#   FAST_WEAKER_COMPRESSION
#

old_os_backap() {
    fdisk -l "$DISK" | grep "^/dev"
    read -p "$ENTER_ROOT_PARTITION" ROOT_PART
    local ROOT_PART="/dev/$ROOT_PART"
    mount "$ROOT_PART" /mnt

    if [ $UEFI_MODE -eq 1 ]; then
        read -p "$ENTER_EFI_PARTITION" BOOT_PART
        echo "$FORMATTING_EFI"
        local BOOT_PART="/dev/$BOOT_PART"
        mount "$BOOT_PART" /mnt/boot/efi
    else
        read -p "$ENTER_BOOT_PARTITION" BOOT_PART
        echo "$FORMATTING_BOOT"
        local BOOT_PART="/dev/$BOOT_PART"
        mount "$BOOT_PART" /mnt/boot
    fi

    local OLD_OS_NAME="OldOS"
    if [ -f /mnt/etc/os-release ]; then
        source /mnt/etc/os-release || source /mnt/usr/lib/os-release
        local OLD_OS_NAME="${NAME:-$ID}"
        local OLD_OS_NAME="${OLD_OS_NAME// /_}"
    fi
    mkdir -p /mnt/old.os/home_backup/

    for old_user in /mnt/home/*/; do
        [ -d "$old_user" ] || continue
        local user=$(basename "$old_user")

        # Сохраняем в /mnt/old.os/home_backup/username/
        local backup_path="/mnt/old.os/home_backup/$user"

        # Копируем с исключением опасных файлов
        rsync -av "$old_user" "$backup_path/" \
            --exclude='.*cache*' \
            --exclude='.*history' \
            --exclude='.ssh' \
            --exclude='.gnupg' \
            --exclude='.local/share/keyrings' \
            --exclude='.mozilla/firefox/*/logins.json' \
            --exclude='*.iso' \
            --exclude='*.img' \
            --exclude='Downloads/' \
            --exclude='.local/share/Trash/'

        echo "Сохранён пользователь $user в $backup_path"


        rm -rf "$old_user"
    done


    rm -rf /mnt/home 2>/dev/null || true


    local EXCLUDE="--exclude=/mnt/*/.cache \
        --exclude=/mnt/var/cache \
        --exclude=/mnt/run \
        --exclude=/mnt/tmp \
        --exclude=/mnt/var/run \
        --exclude=/mnt/var/lock \
        --exclude=/mnt/swapfile \
        --exclude=/mnt/lost+found \
        --exclude=/mnt/.snapshots \
        --exclude=/mnt/srv \
        --exclude=/mnt/mnt \
        --exclude=/mnt/media \
        --exclude=/mnt/home \
        --exclude=/mnt/swap.img \
        --exclude=/mnt/.Trash* \
        --exclude=/mnt/*/backup*"

    # Создаём каталог для архива
    mkdir -p /mnt/old.os

    old_os_back=$(dialog --title "$SELECT_MODE_TITLE" --menu "$SELECT_MODE_MENU" 15 60 3 \
        1 "tar.xz ($BEST_COMPRESS_SPEED)" \
        2 "tar.zst (баланс)" \
        3 "tar.gz ($FAST_WEAKER_COMPRESSION)" 3>&1 1>&2 2>&3 3>&-)

    case "$old_os_back" in
        1) tar $EXCLUDE -c /mnt | xz -9 > "/mnt/old.os/${OLD_OS_NAME}_backup.tar.xz" ;;
        2) tar $EXCLUDE -c /mnt | zstd -19 -T0 > "/mnt/old.os/${OLD_OS_NAME}_backup.tar.zst" ;;
        3) tar $EXCLUDE -c /mnt | pigz -c > "/mnt/old.os/${OLD_OS_NAME}_backup.tar.gz" ;;
    esac

    # 3. Удаляем всё кроме old.os и boot
    # 1. Сначала проверь, что найдётся:
    local TARGET="/mnt"

    # Проверка монтирования
    if ! mountpoint -q "$TARGET"; then
        echo "$TARGET не примонтирован. Выход."
        exit 1
    fi

    # Проверка наличия нужных каталогов
    for dir in old.os boot; do
        if [[ ! -d "$TARGET/$dir" ]]; then
            echo "Предупреждение: $TARGET/$dir не существует!"
        fi
    done

    # Удаляем всё, кроме old.os и boot
    find "$TARGET" -maxdepth 1 -mindepth 1 ! -name 'old.os' ! -name 'boot' -exec rm -rf {} +

}

# Функция авторазметки
auto_partition() {
    echo "$AUTO_PARTITION_TITLE"

    # Получаем размер диска в GB
    DISK_SIZE=$(fdisk -l "$DISK" | grep "Disk $DISK" | awk '{print int($3)}')
    printf "${DISK_SIZE}\n" "$DISK_SIZE"

    # Проверяем, достаточно ли места
    if [ "$DISK_SIZE" -lt 10 ]; then
        echo "$DISK_TOO_SMALL"
        exit 1
    fi

    # Очищаем таблицу разделов
    echo "$CLEAN_PARTITION_TABLE"
    sgdisk -Z "$DISK" 2>/dev/null || dd if=/dev/zero of="$DISK" bs=1M count=100

    # Создаем новую таблицу разделов
    if [ $UEFI_MODE -eq 1 ]; then
        echo "$CREATE_GPT"
        parted -s "$DISK" mklabel gpt
    else
        echo "$CREATE_MBR"
        parted -s "$DISK" mklabel msdos
    fi

    # Создаем разделы
    echo "$CREATING_PARTITIONS"

    if [ $UEFI_MODE -eq 1 ]; then
        # UEFI: ESP + swap + root
        parted -s "$DISK" mkpart primary fat32 1MiB 513MiB
        parted -s "$DISK" set 1 esp on
        export BOOT_PART="${DISK}1"

        parted -s "$DISK" mkpart primary 513MiB 4.5GiB
        export SWAP_PART="${DISK}2"

        parted -s "$DISK" mkpart primary 4.5GiB 100%
        export ROOT_PART="${DISK}3"
    else
        # BIOS: boot + swap + root
        parted -s "$DISK" mkpart primary 1MiB 513MiB
        parted -s "$DISK" set 1 boot on
        export BOOT_PART="${DISK}1"

        parted -s "$DISK" mkpart primary 513MiB 4.5GiB
        export SWAP_PART="${DISK}2"

        parted -s "$DISK" mkpart primary 4.5GiB 100%
        export ROOT_PART="${DISK}3"
    fi

    partprobe "$DISK"
    sleep 2

    echo "$CREATED_PARTITIONS_TITLE"
    fdisk -l "$DISK" | grep "^/dev"
    echo "========================="
}
# Функция форматирования разделов
format_partitions() {
    echo "$FORMATTING_TITLE"

    # Форматируем EFI/Boot раздел
    if [ $UEFI_MODE -eq 1 ]; then
        echo "$FORMATTING_EFI"
        mkfs.fat -F32 "$BOOT_PART"
    else
        echo "$FORMATTING_BOOT"
        mkfs.ext2 -F "$BOOT_PART"
    fi

    # Форматируем корневой раздел (ext4)
    echo "$FORMATTING_ROOT"
    mkfs.ext4 -F "$ROOT_PART"

    # Форматируем recovery раздел (ext2)
    echo "$FORMATTING_RECOVERY"
    mkfs.ext2 -F "$RECOVERY_PART"

    # Создаем swap
    echo "$CREATING_SWAP"
    mkswap "$SWAP_PART"
    swapon "$SWAP_PART"

    echo "$FORMATTING_COMPLETE"
}

# Функция монтирования разделов
mount_partitions() {
    echo "$MOUNTING_TITLE"

    # Монтируем корневой раздел
    mount "$ROOT_PART" /mnt

    # Создаем и монтируем boot/efi
    if [ $UEFI_MODE -eq 1 ]; then
        mkdir -p /mnt/boot/efi
        mount "$BOOT_PART" /mnt/boot/efi
    else
        mkdir -p /mnt/boot
        mount "$BOOT_PART" /mnt/boot
    fi

    # Создаем и монтируем recovery
    mkdir -p /mnt/recovery
    mount "$RECOVERY_PART" /mnt/recovery

    echo "$MOUNTING_COMPLETE"
}

# Основное меню выбора режима разметки
echo "$SELECT_PARTITIONING_MODE"
MODE=$(dialog --title "$SELECT_MODE_TITLE" --menu "$SELECT_MODE_MENU" 15 60 3 \
    1 "$AUTO_MODE" \
    2 "$MANUAL_MODE" \
    3 "${OS_CHANGE_TITLE} beta" \
    4 "$EXIT_MODE" 3>&1 1>&2 2>&3 3>&-)

clear

case $MODE in
    1)
        echo "$AUTO_SELECTED"
        auto_partition
        format_partitions
        mount_partitions
        ;;
    2)
        echo "$MANUAL_SELECTED"
        # Оригинальный код для ручной разметки
        cfdisk "$DISK"

        read -p "$ENTER_ROOT_PARTITION" ROOT_PART
        ROOT_PART="/dev/$ROOT_PART"
        [ ! -e "$ROOT_PART" ] && printf "${PARTITION_ERROR}\n" "$ROOT_PART" && exit 1

        luks_enable_root() {
            echo "$LUKS_TITLE"
            cryptsetup luksFormat --type luks2 --verify-passphrase "$ROOT_PART"

            # 2. Передаем пароль в cryptsetup
            cryptsetup luksOpen "$ROOT_PART" "QuasarRoot"
            export LUKS_MODE=1
        }

        luks=$(dialog --title "$ENCRYPT_ROOT_TITLE" --menu "$ENCRYPT_ROOT_MENU" 15 70 5 \
            1 "$YES" \
            2 "$NO" 3>&1 1>&2 2>&3 3>&-)

        case $luks in
                1) luks_enable_root ;;
                2) true ;;
        esac

        format() {
            ext() {
                if [ $LUKS_MODE -eq 1 ]; then
                    mkfs.ext4 "/dev/mapper/QuasarRoot"
                else
                    mkfs.ext4 -F "$ROOT_PART"
                fi
            }

            btrfs() {
                if [ $LUKS_MODE -eq 1 ]; then
                     mkfs.btrfs -f "/dev/mapper/QuasarRoot"
                else
                     mkfs.btrfs -f "$ROOT_PART"
                fi
            }

            xfs() {
                if [ $LUKS_MODE -eq 1 ]; then
                    mkfs.xfs -f "/dev/mapper/QuasarRoot"
                else
                    mkfs.xfs -f  "$ROOT_PART"
                fi
            }

            fs=$(dialog --title "$FILESYSTEM_TITLE" --menu "$FILESYSTEM_MENU" 15 70 5 \
                1 "$EXT4" \
                2 "$BTRFS" \
                3 "$XFS" 3>&1 1>&2 2>&3 3>&-)

            if [ $? -ne 0 ]; then
                echo "$SKIPPING"
                exit 0
            fi

            case $fs in
                1) ext ;;
                2) btrfs ;;
                3) xfs ;;
            esac
            clear
            if [ $LUKS_MODE -eq 1 ]; then
                mount /dev/mapper/QuasarRoot /mnt
            else
                mount "$ROOT_PART" /mnt
            fi
        }
        format

        lsblk -o NAME,SIZE,FSTYPE,MOUNTPOINT $DISK
        if [ $UEFI_MODE -eq 1 ]; then
            read -p "$ENTER_EFI_PARTITION" BOOT_PART
            echo "$FORMATTING_EFI"
            export  BOOT_PART="/dev/$BOOT_PART"
            mkdir -p /mnt/boot/efi
            mkfs.fat -F32 "$BOOT_PART"
            mount "$BOOT_PART" /mnt/boot/efi
        else
            read -p "$ENTER_BOOT_PARTITION" BOOT_PART
            echo "$FORMATTING_BOOT"
            BOOT_PART="/dev/$BOOT_PART"
            mkdir -p /mnt/boot
            mkfs.ext2 -F "$BOOT_PART"
            mount "$BOOT_PART" /mnt/boot
        fi

        [ ! -e "$BOOT_PART" ] && printf "${PARTITION_ERROR}\n" "$BOOT_PART" && exit 1

        # Дополнительные опции для ручного режима
        read -p "$CREATE_RECOVERY_QUESTION" CREATE_RECOVERY
        if [[ $CREATE_RECOVERY =~ ^[Yy]$ ]]; then
            read -p "$ENTER_RECOVERY_PARTITION" RECOVERY_PART
            echo "$FORMATTING_RECOVERY"
            RECOVERY_PART="/dev/$RECOVERY_PART"
            mkfs.ext2 -F "$RECOVERY_PART"
            mkdir -p /mnt/recovery
            mount "$RECOVERY_PART" /mnt/recovery
        fi

        read -p "$CREATE_SWAP_QUESTION" CREATE_SWAP
        if [[ $CREATE_SWAP =~ ^[Yy]$ ]]; then
            read -p "$ENTER_SWAP_PARTITION" SWAP_PART
            SWAP_PART="/dev/$SWAP_PART"
            mkswap "$SWAP_PART"
            swapon "$SWAP_PART"
        fi

        echo "$FINAL_LAYOUT_TITLE"
        lsblk -o NAME,SIZE,FSTYPE,MOUNTPOINT $DISK
        echo "$PARTITIONING_COMPLETE"
        ;;
    3) old_os_backap ;;

    4)
        echo "$EXITING"
        exit 0
        ;;
    *)
        echo "$UNKNOWN_CHOICE"
        exit 1
        ;;
esac


echo "$FINAL_LAYOUT_TITLE"
lsblk -o NAME,SIZE,FSTYPE,MOUNTPOINT "$DISK"
echo "========================="
echo ""
echo "$PARTITIONING_COMPLETE"

